## 什么是递归？
程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
> 来自于[百度百科](https://baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695)

## 为什么要学习递归？
递归在数据结构与算法中有着一席之地，统治着江山。大部分的LeetCode题都可以用递归去解决，如：二叉树的遍历、回溯算法、0-1 背包问题、深度优先遍历、回溯算法等等。

## 如何理解递归

1. 问题
假如在大学里插队打饭，那么队伍后边的同学本数着自己前边还有 5 个同学就改轮到自己了，由于前边同学不断的插队，这时他发现，怎么觉得自己离着打饭的窗口越来越远呢？这时如果他想知道自己在队队列中的的第几个（前提是前边不再有人插队），用递归思想来解决，我们怎么做呢？

2. “递”
于是他问前边的同学是第几位，前边的同学也不只到呀，于是前边的同学问他前边的同学是第几位，直到前边第二个同学问到第一个正在打饭的同学是队伍的第几个（有点小尴尬）。打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？这个过程其实是就是一个递归中“递”的过程。

3. “归”
然后前边打饭的第二个同学不耐烦的又告诉第三个同学，我是第二个，没看到我前边有个家伙正在打饭吗？然后第三个传给第四个，以后往后传，直到那位逐渐远离窗口的同学的前一个人告诉他是第几个之后，他知道了自己目前在队伍中的第几个位置。这个过程我们可以理解为递归中“归”的过程。

4. 终止条件
“打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？”，在递归中，我们称为终止条件。

5. 怎么理解递归
问题虽然是层层递归的分析，但是用程序表示的时候，不要层层的在大脑中调用递归代码去想，这样可能会使你完全陷入到 “递” 的过程中去，“归” 的时候，归不出来了，这些都是我们交给计算机干的事情。


那我们在写程序的时候怎么理解递归呢？我们只找问题之间存在的关系，屏蔽掉递归的细节。

## 满足递归的条件
什么样的问题才能满足用递归解决呢？具有什么样的特征，有没有判断条件？

1. 一个问题能不能分解成多个子问题来解决
2. 该问题是否和子问题的解决方法相同
3. 该问题是否有终止条件

## 递归的分类
之所以将其分类，是为了能够更好的理解递归在不同的问题下起着什么作用，如：每层递归之间存在的关系、计算，以及递归枚举所有情况和面临选择性问题的递归。虽然分为了几类，但是递归的本质是一成不变的。

### 分类一：递归计算型

   1. 层层计算
   层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。

   > 例子
    那上方排队打饭的例子来说明，我们的**子问题**已经分析出来了，**就是我想知道当前在队伍中的位置，就是去问我前边人的位置加一就是我当前队伍的位置**，这为一层。而前边这个人想知道当前自己的位置，需要用同样的解决思路，作为另一层。

    层与层之间的关系是什么（我当前队伍中的位置与前边人的位置存在什么样的关系）？这时你会说，当前是 +1。这个大部分人都很容易找出，既然关系确定了，然后通过递推公式很容易写出递归代码。
    
    ```
    1   // f(n) 为我所在的当前层
    2   // f(n-1) 为我前边的人所在的当前层
    3   // + 1 是层与层之间的计算关系
    4   f(n) = f(n-1) + 1
    ```

    > 总结：将以上一类递归问题命名为「递归计算型」的「层层计算类型」。
    >
    > 举一反三：求年龄的问题也是层层计算类型的问题，自己尝试分析一下（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。
       - **问题一**：有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。

       - **问题二**：单链表从尾到头一次输出结点值，用递归实现。

   2. 并列计算
   并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。

   > 例子
   最经典的题型就是**斐波那契数列**。观察这样一组数据0、 1、1、2、3、5、8、13、21、34...，去除第一个和第二个数据外，其余的数据等于前两个数据之和（如：2 = 1 + 1，8 = 3 + 5，34 = 21 + 13）。你可以尝试着根据「满足递归的三个条件」以及「怎么写出递归代码」的步骤自己动手动脑亲自分析一下。

   1）第一步：首先判断能不能将问题分解为多个子问题，上边我也分析过了，除了第一个和第二个数据，其他数据是前两个数据之和。那么前两个数据怎么知道呢？同样的解决方式，是他们前两个数之和。

   2）第二步：找到终止条件，如果不断的找到前两个数之和，直到最前边三个数据 0、1、1 。如果递归求第一个 1 时，前边的数据不够，所以这也是我们找到的终止条件。

   3）第三步：既然我们终止条件和关系找到了，递推公式也就不难写出 f(n) = f(n-1) + f(n-2)（n 为要求的第几个数字的值）。

   4）转化为递归代码如下：
   ```
    function f(n) {
        // 终止条件
        if(n == 0) return 0;
        if(n == 1) return 1;
        // 递推公式
        return f(n-1) + f(n-2);
    }
   ```

   > 总结 ：我将上方的问题总结为并列计算型。也可以归属为层层计算的一种，只不过是 + 1 改成了加一个 f 函数自身的递归（说白了，递归的结果也是一个确切的数值）。
   >
   > 之所谓并列计算 f(n-1) 和 f(n-2) 互不打扰，各自递归计算各的值。最后我们将其计算的结果值相加是我们最想要的结果。
   >
   > 举一反三：
      - **问题**：一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。

### 分类二：递归枚举型
递归枚举型最多的应用就是**回溯算法**，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。

> 回溯算法最经典的问题又深度优先遍历、八皇后问题等，应用非常广泛，下边以八皇后问题为例子，展开分析，其他利用递归枚举型的回溯算法就很简单了。

   - 八皇后问题
   在 8 X 8 的网格中，放入八个皇后（棋子），满足的条件是，任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，问有多少种摆放方式？

   图(1) 八皇后错误情况
   [](./image/八皇后错误情况.png)

   图(2) 八皇后正确情况
   [](./image/八皇后正确情况.png)

   1. 问题分析
   要想满足任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，需要一一枚举皇后（棋子）的所有摆放情况，然后设定条件，筛选出满足条件的情况。

   2. 算法思路
   我们把问题分析清楚了之后，怎么通过递归实现回溯算法枚举八个皇后（棋子）出现的所有情况呢？

      1）我们在 8 X 8 的网格中，先将第一枚皇后（棋子）摆放到第一行的第一列的位置（也就是坐标: (0,0)）。
   
      2）然后我们在第二行安置第二个皇后（棋子），先放到第一列的位置，然后判断同一行、同一列、同一斜线是否存在另一个皇后？如果存在，则该位置不合适，然后放到下一列的位置，然后在判断是否满足我们设定的条件。
   
      3）第二个皇后（棋子）找到合适的位置之后，然后在第三行放置第三枚棋子，依次将八个皇后放到合适的位置。
   
      4）这只是一种可能，因为我设定的第一个皇后是固定位置的，在网格坐标的（0,0） 位置，那么怎么枚举所有的情况呢？然后我们不断的改变第一个皇后位置，第二个皇后位置...... ，就可以枚举出所有的情况。如果你和我一样，看了这个题之后，如果还有点懵懵懂懂，那么直接分析代码吧。

   3. 代码实现 -- javascript 
      - 将问题分解为多个子问题

      - 找出终止条件
      当遍历到第八行的时候，递归结束。
      ```
      // 终止条件
        if(row === 8){
      // 打印第 n 种满足的情况
        console.log(result)
        n++;
        return;
        }
      ```

      - 写出递推公式
      isOkCulomn() 函数判断找到的该位置是否满足条件（不能处于同一行、同一列或同一斜线上）。如果满足条件，我们返回 true，进入 if 判断，row行数加一传入进行递归下一行的皇后位置。直至递归遇到终止条件位置，column ++，将第一行的皇后放到下一位置，进行继续递归，枚举出所有可能的摆放情况。
      ```
        1// 每一列的判断
        2for(let column = 0; column < 8; column++){
        3    // 判断当前的列位置是否合适
        4    if(isOkCulomn(row,column)){
        5        // 保存皇后的位置
        6        result[row] = column;
        7        // 对下一行寻找数据
        8        cal8queens(row + 1);
        9    }
        10    // 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性
        11}
      ```
      ```
        1// 判断当前列是否合适
        2const isOkCulomn = (row,column) =>{
        3    // 左上角列的位置
        4    let leftcolumn = column - 1;
        5    // 右上角列的位置
        6    let rightcolumn = column + 1;
        7
        8    for(let i = row - 1;i >= 0; i--){
        9        // 判断当前格子正上方是否有重复
        10        if(result[i] === column) return false;
        11
        12        // 判断当前格子左上角是否有重复
        13        if(leftcolumn >= 0){
        14            if(result[i] === leftcolumn) return false;
        15        }
        16
        17        // 判断当前格式右上角是否有重复
        18        if(leftcolumn < 8){
        19            if(result[i] === rightcolumn) return false;
        20        }
        21
        22        // 继续遍历
        23        leftcolumn --;
        24        rightcolumn ++;
        25    }
        26    return true;
        27}
      ```

      - [转换为递归代码](https://mp.weixin.qq.com/s?__biz=MzIwODg1OTkzNw==&mid=2247484598&idx=1&sn=22f201706620c03d62199a1c95cab12c&chksm=977de2f8a00a6bee91e24f47225d39d8dec9980cd60e68aac7e2604313213c14da73f4a31f64&mpshare=1&scene=23&srcid=&sharer_sharetime=1573523233856&sharer_shareid=146e00a5d117656b5e8159f8890e708c#rd)


### 分类三：递归选择型
所谓的递归选择型，每个子问题都要面临选择，求最优解的情况。有的小伙伴会说，求最优解动态规划最适合，对的，没错，但是递归通过选择型枚举所有情况，设置条件，求得问题的最优解也是可以实现的，所有我呢将其这一类问题归为递归选择型问题。

> 0 -1 背包问题
0 - 1 背包问题，了解过的小伙伴也是很熟悉的了。其实这个问题也属于回溯算法的一种，废话不多说，直接上问题。有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？

- 问题分析
假如每个物品我们有两种状态，总的装法就有 2^n种，怎么才能不重复的穷举这些可能呢？

- 算法思路
我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。

- [代码实现](https://mp.weixin.qq.com/s?__biz=MzIwODg1OTkzNw==&mid=2247484598&idx=1&sn=22f201706620c03d62199a1c95cab12c&chksm=977de2f8a00a6bee91e24f47225d39d8dec9980cd60e68aac7e2604313213c14da73f4a31f64&mpshare=1&scene=23&srcid=&sharer_sharetime=1573523233856&sharer_shareid=146e00a5d117656b5e8159f8890e708c#rd)


___
## 递归的缺点
虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。

1. 递归堆栈溢出
1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。

2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。

3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。

> 解决办法
>
> 通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。

2. 递归重复元素
有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。

> 解决办法
>
> 重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ）

3. 递归高空间复杂度
因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。
