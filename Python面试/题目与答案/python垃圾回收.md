## 问：说说Python中的垃圾回收机制？

## 答：**垃圾回收机制（Garbage Collection:GC）**基本是所有高级语言的标准配置之一了，在一定程度上，能优化编程语言的数据处理效率和提高编程软件开发软件的安全性能 。在python中的垃圾回收机制主要是以**引用计数**为主要手段以**标记清除**和**隔代回收**机制为辅的手段 。可以对内存中无效数据的自动管理！

> [关于垃圾回收]https://github.com/2048JiaLi/my-learning-100days/blob/master/1108-day10.md

### 三种的区别
1. 引用计数

Python语言默认采用的垃圾收集机制是：引用计数法，该算法最早George E. Collins在1960的时候首次提出，到如今已经快60年了，该算法依然被很多编程语言使用。

**引用计数法核心原理**是：每个对象维护一个`ob_ref`字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数`ob_ref`加1，每当该对象的引用失效时计数`ob_ref`减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。

**优点**
高效，实时性能优秀，能在最短的时间获得并运算对象引用数，对象有确定的生命周期，操作简单，易于实现 。 

**缺点**
   - 维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。
   - 无法解决**循环引用**的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。


**为了解决这两个致命弱点，Python又引入了以下两种GC机制。**

2. 标记-清除

**标记-清除**算法是一种基于**追踪回收**（tracing GC）技术实现的垃圾回收算法，主要是针对可能产生循环引用的对象进行的检测机制 。

它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。

GC是如何判断哪些是活动对象哪些是非活动对象呢？

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。**从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象**。

根对象就是全局变量、调用栈、寄存器。

![image](https://mmbiz.qpic.cn/mmbiz_svg/QnM5bMcic4Z3wy1HvwFM2CI51rCoaYFVicmzH2mJuReUEIgibqGW2iaLE430z2ribQJeWIX39bgMy3QkzQDstBAOmS9EJlDictBFno/640?wx_fmt=svg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> 如上图中，把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。

3. 分代回收

**分代回收是建立在标记清除技术基础之上，是一种以空间换时间的操作方式**。

Python将内存根据**对象的存活时间**划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。

新创建的对象都会分配在年轻代（0代），**年轻代链表的总数达到上限时**，Python垃圾收集机制就会被触发，把那些**可以被回收的对象回收掉**，而**那些不会回收的对象就会被移到中年代（1代）去**，依此类推，老年代（2代）中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。